
# Git?

**Git**  — мощная и сложная распределенная система контроля версий. Понимание всех возможностей git открывает для разработчика новые горизонты в управлении исходным кодом. Самый верный способ обучиться владению Git — испытать его своими руками.

## Установка Git

Основой интерфейс для работы с **Git**-ом является консоль/терминал.

Установка **Git**:

### - Windows 

Переходим по этой [***ссылке***](https://git-scm.com/download/win), выбираем под вашу ОС (32 или 64 битную), скачиваем и устанавливаем.

### - MacOS
![MaxOs install](/MacOS_install.png)

### - Linux (**Ubuntu, ArchLinx**)
**Debian или Ubuntu**  

`sudo apt install git`

**ArchLinux**  

`sudo pacman -S git`
	
## Настройка Git 

Вы установили себе Git и можете им пользоваться. Давайте теперь его настроим, чтобы когда вы создавали commit, указывался автор, кто его создал. Выполните следующие команды, чтобы git узнал ваше имя и электронную почту. Если git уже установлен, можете переходить к разделу окончания строк.

**Выполнить:**  
`git config --global user.name "Your Name"`  
и  
`git config --global user.email "your_email@whatever.com"`

## Параметры установки окончания строк
**Для пользователей** ***Unix/Mac***

**Выполнить:**  
`git config --global core.autocrlf input`  
и  
`git config --global core.safecrlf warn`
	
**Для пользователей** ***Windows***

**Выполнить:**

`git config --global core.autocrlf input`       
и 
`git config --global core.safecrlf warn`

## Создание репозитория

Чтобы создать git репозиторий из каталога, выполните команду git init в этом каталоге.

**Выполните:**

`git init`	
	
## Добавить файлы или новые файлы в репозиторий

Теперь давайте добавим в репозиторий страницу «Hello, World» - hello.html.

**Выполните:**

 `git add hello.html` 
 и 
 `git commit -m "First Commit"`
	
где "First commit" - Коммит - Название(Комментарий к) точки сохранения).

## Проверка текущего состояния репозитория

Используйте команду ***git status***, чтобы проверить текущее состояние репозитория.

**Выполните:**

`git status`	
	
Команда проверки состояния сообщит, что коммитить нечего. Это означает, что в репозитории хранится текущее состояние рабочего каталога, и нет никаких изменений, ожидающих записи.

Команда ***git status***, необходима, чтобы продолжать отслеживать состояние репозитория и рабочего каталога.

## Добавление изменений

Если вы изменили файлы или добавили новые файлы, то набрав команду ***git status*** вы можете увидить следующий результат:

"git status
On branch master
Changes not staged for commit:
   (use "git add <file>..." to update what will be committed)
   (use "git checkout -- <file>..." to discard changes in working directory)

   modified:   hello.html

no changes added to commit (use "git add" and/or "git commit -a")"

Первое, что нужно заметить, это то, что git знает, что файл hello.html был изменен, но при этом эти изменения еще не зафиксированы в репозитории.

Также обратите внимание на то, что сообщение о состоянии дает вам подсказку о том, что нужно делать дальше. Если вы хотите добавить эти изменения в репозиторий, используйте команду ***git add***. В противном случае используйте команду ***git сheckout*** для отмены изменений.

**Добавим изменения**

Дадим команду git проиндексировать изменения.

***Выполнить:***

`git add hello.html`

Изменения файла ***hello.html*** были проиндексированы. Это означает, что **git** теперь знает об изменении, но изменение пока не перманентно (читай, навсегда) записано в репозиторий. Следующий коммит будет включать в себя проиндексированные изменения.

***Если вы решили, что не хотите коммитить изменения, команда состояния напомнит вам о том, что с помощью команды **git reset** можно снять индексацию этих изменений.***

Отдельный шаг индексации в git позволяет вам продолжать вносить изменения в рабочий каталог, а затем, в момент, когда вы захотите взаимодействовать с версионным контролем, git позволит записать изменения в малых коммитах, которые фиксируют то, что вы сделали.

Предположим, что вы отредактировали три файла (a.html, b.html, и c.html). Теперь вы хотите закоммитить все изменения, при этом чтобы изменения в a.html и b.html были одним коммитом, в то время как изменения в c.html логически не связаны с первыми двумя файлами и должны идти отдельным коммитом.

В теории, вы можете сделать следующее:

	`git add a.html`
Затем
`git add b.html`

Затем

`git commit -m "Changes for a and b"`

Затем
`git add c.html` 
	
И наконец  

`git commit -m "Unrelated change to c"`
	
Разделяя индексацию и коммит, вы имеете возможность с легкостью настроить, что идет в какой коммит.
	
	
